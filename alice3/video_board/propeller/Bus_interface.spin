{{

This code has two roles, it runs the Z80 clock via CTRA and
interfaces with the Z80 I/O bus to provide some peripherals. 

It does the latter by watching for IORQ==0 && A7==1, and then using
A0/A1/A2 to determine which I/O port ("OUT 128..135, n") is being
accessed.  In some cases where the message is only a single byte
long it processes it immediately; in other cases handlers are broken
up into state machines so that they can handle a command followed
by parameters.

The sounds are generated by an AY-3-8910 emulator, running in a
single cog.  This emulator exposes 16 registers, just like the
original General Instruments chip.  You can easily kick off little
chirps and things by copying a 16 byte block into these registers,
as the boot sequence does.

* OUT 128 - Enqueues bytes to the VGA/VT100 drivers
* OUT 129 - Sets registers in the AY-3-8910 emulator ; two modes:
    * OUT 129, reg_number (0..15) ; OUT 129, reg_value
    * OUT 129, 16 ; OUT 129, reg0_value ; OUT 129, reg1_value ; ... ; OUT 129, reg15_value
* IN  130 - Reads custom timer
* OUT 130 - Sets custom timer ; two modes, direct (0) and "per second":
    * OUT 130, 0 ; OUT 130, byte_0 ; OUT 130, byte_1 ; OUT 130, byte_2 ; OUT 130, byte_3
    * OUT 130, 1 ; OUT 130, ticks_per_sec  (!not yet implemented!)
* OUT 131 - Write directly to the character buffer
    * Set X, set Y, set count, then write count bytes
* OUT 132 - Write directly to the color buffer
    * Set Y, write color byte
    * color byte is arranged %F0RRGGBB, two bits per color, bit 6 ignored, bit 7 is fg/bg (0/1)

TODO:

* ct_persecond handler (stubbed, but "per second" math not implemented)
    * Send 1 to start, then a byte of how many ticks per second:  OUT 130, 1;  OUT 130, 60;
* charset setting handlers
* serial terminal output (mirroring, per-char, etc.)
    * this is commented-out in the code below, it should probably be moved over to Terminal.spin
* CP/M programs that test each capability of this code
    * cpuspeed.com - get/set CPU speed
    * custmtmr.com - get/set programmable timer 
    * ztunes.com   - more fully-featured ym player that used direct framebuffer to draw a nice interface
    * fgcolor.com/bgcolor.com - get/set fg/bg color
* dumpdebug function needs rewriting
* Future feature ideas
    * New video modes:  a>SETVIDEO 320x240.DRV
    * Firmware emulation drivers:  a>EMULATE PACMAN.EMU  or a>EMULATE COLECO.EMU SMURFS.ROM

}}

CON
    _xinfreq = 5_000_000
    _clkmode = xtal1 + pll16x
    PROP_SPEED = _xinfreq * 16

    Z_CLK  = 5
    Z_IORQ = 1    ' Active low.
    Z_WR   = 2    ' Active low.
    Z_RD   = 3    ' Active low.

    Z_D0   = 16   ' First data pin.
    Z_A7   = 4    ' Active high.
    Z_A0   = 24   ' Active high.
    Z_A1   = 25   ' Active high.
    Z_A2   = 26   ' Active high.

    BP_1   = 6    ' bartport
    BP_2   = 7
    BP_3   = 27

    Z80_SPEED = 2_000_000  ' 2_250_000 is about as fast as ARMasRAM can go


PUB start(QueuePtr, {HeadIndexPtr,} TailIndexPtr, Capacity, AYPtr, screen, colors, cols, serial_tx)

    queue_ptr      := QueuePtr
    'head_ptr      := HeadIndexPtr   ' not needed
    tail_ptr       := TailIndexPtr
    cap_mask       := Capacity - 1
    ay_ptr         := AYPtr
    dfb_screen_ptr := screen
    dfc_screen_ptr := colors
    dfb_cols       := cols << 8  ' preparing for the bitwise multiply below

    tx             := serial_tx

    ' What we really want to express is this:
    ' z80_FRQ := $FFFF_FFFF / (PROP_SPEED / Z80_SPEED)
    ' ...but SPIN only deals with signed 32-bit numbers so
    ' we do this at a lower precision and multiply with
    ' the understanding that the intermediate and final
    ' results aren't greater than MAXINT
    z80_FRQ := $7FFF_FFFF / (PROP_SPEED / Z80_SPEED)
    z80_FRQ := z80_FRQ * 2
    z80_CTR := (%00100 << 26) | Z_CLK        ' NCO single-ended

    ' On 80MHz prop: 1Hz == $0000_001A 60Hz == $0000_064A, 1KHz == $0000_68DB, 10KHz == $0004_1893
    ct_FRQ := $0000_053E
    ct_CTR := (%00100 << 26) | BP_3          ' NCO single-ended

    z80_DIRWR := |<Z_CLK | |<BP_3                ' output z80 clock only
    z80_DIRRD := |<Z_CLK | |<BP_3 | ($FF<<Z_D0)  ' output z80 clock + data pins

    cognew(@init, 0)


DAT

            org 0

' - - - - Set up our handler state machines
init
            movs    ay_state, #ay_start    ' initialize "ay" state machine pointer
            movs    ct_state, #ct_start    ' initialize "ct" state machine pointer
            movs    dfb_state, #dfb_start  ' initialize "dfb" state machine pointer
            movs    dfc_state, #dfc_start  ' initialize "dfc" state machine pointer

' - - - - Start the Z80 clock, initial custom timer, set up our bus mask
businit
            mov     dira, z80_DIRWR
            ' Configure CTRA/FRQA so that PHSA[31] oscillates at Z80_SPEED Hz
            mov     ctra, z80_CTR
            mov     frqa, z80_FRQ
            ' The z80 clock should now be oscillating

            mov     ctrb, ct_CTR
            mov     frqb, ct_FRQ

            ' We're looking for IORQ low and A7 high.
            mov     bus_pattern, #(|<Z_A7)  ' Z_IORQ is active *LOW*
           'mov     bus_mask, #(|<Z_IORQ | |<Z_WR | |<Z_RD | |<Z_A7)
            mov     bus_mask, #(|<Z_IORQ | |<Z_A7)

' - - - - Bus watcher and handler jump tables
loop       ' Wait for A7 and !IORQ to be asserted, we eval write/read next
            waitpeq bus_pattern, bus_mask

            'mov     ctra, #0    ' pause Z80 clock
            mov     bus_data, ina   ' immediately read all input pins

            mov     io_addr, bus_data
            shr     io_addr, #Z_A0
            and     io_addr, #7
            test    bus_data, #(|<Z_WR)      wz
    if_z    add     io_addr, #out_handlers  ' WR line was low, which is *active*, this is a write ("OUT port, n")
    if_nz   add     io_addr, #in_handlers   ' WR line was high, which is *inactive*, this is a read ("IN port")
            shr     bus_data, #Z_D0            ' The shr and and ended up as the first two instructions on almost
            and     bus_data, #$FF             ' every handler so they've been moved to the main loop
            jmp     io_addr

out_handlers
            jmp     #terminal_in   '0 - enquque byte for the terminal
            jmp     ay_state       '1 - jump to the address *ay_state
            jmp     ct_state       '2 - ditto
            jmp     dfb_state      '3 - ditto
            jmp     dfc_state      '4
            jmp     #complete      '5
            jmp     #complete      '6
            jmp     #complete      '7

in_handlers
            jmp     #complete      '0 - no reads from terminal
            jmp     #complete      '1 - no reads from ay
            jmp     #ct_read       '2
            jmp     #complete      '3
            jmp     #complete      '4
            jmp     #complete      '5
            jmp     #complete      '6
            jmp     #complete      '7

' - - - - VT100 terminal queue

terminal_in
            ' Shift data into low byte, wrbyte below will handle masking

            ' Write to queue
            rdlong  tail, tail_ptr
            mov     TMP, tail
            add     TMP, queue_ptr
            wrbyte  bus_data, TMP  ' only copies lowest byte

            ' Advance queue.
            add     tail, #1
            and     tail, cap_mask
            wrlong  tail, tail_ptr

            ' Send the byte to the terminal
'tx_wait     rdlong  TMP,tx
'            shl     TMP,#1  WC
'     if_nc  jmp     #tx_wait
'            wrlong  bus_data,tx

            cmp     bus_data, #$07  wz  ' ASCII BEL
    if_z    call    #ay_BEL

            jmp #complete
' - - - -

' - - - - Direct framebuffer state machine
dfb_start
dfb_recv_x
            mov     dfb_write_ptr, dfb_screen_ptr
            add     dfb_write_ptr, bus_data
            movs    dfb_state, #dfb_recv_y
            jmp #complete

dfb_recv_y
            ' bus_data *= dfb_cols
            ' 8-bit multiply adapted from Prop manual, Appendix B
            ' would be 1/3rd faster if unrolled
            ' dfb_cols is already << 8
            mov     TMP, #8
            shr     bus_data, #1        wc  ' initial LSB multiplier into c
:loop  if_c add     bus_data, dfb_cols  wc  ' if c was set add dfb_cols, wc will always clear c
            rcr     bus_data, #1        wc  ' next LSB multiplier into c, shift product
            djnz    TMP,  #:loop        ' loop until done (16 times)

            add     dfb_write_ptr, bus_data
            movs    dfb_state, #dfb_recv_count
            jmp #complete

dfb_recv_count
            mov     dfb_count, bus_data
            movs    dfb_state, #dfb_recv_chars
            jmp #complete

dfb_recv_chars
            ' Could be faster if it did the writes one long at a time,
            ' but that would probably mean splitting this into four...
            wrbyte  bus_data, dfb_write_ptr  ' only copies lowest byte
            add     dfb_write_ptr, #1
            sub     dfb_count, #1       wz
    if_z    movs    dfb_state, #dfb_start
            jmp #complete

' Color update state machine handlers

dfc_start
            and     bus_data, #$3F  ' only rows 0..63
            shl     bus_data, #1  ' 16-bit words for each color
            mov     dfc_write_ptr, dfc_screen_ptr
            add     dfc_write_ptr, bus_data
            movs    dfc_state, #dfc_set_color
            jmp #complete

dfc_set_color
            test    bus_data, #$80      wz
    if_nz   add     dfc_write_ptr, #1  ' Foreground or background?
            and     bus_data, #$3F  ' only 6 bits of color...
            shl     bus_data, #2    ' ... in the top 6 bits
            wrbyte  bus_data, dfc_write_ptr  ' only copies lowest byte
            movs    dfc_state, #dfc_start
            jmp #complete


' - - - -

' - - - - AY-3-8910 register update state machine

ay_start
            cmp     bus_data, #16       wc
            ' All 16 registers at once
    if_nc   mov     ay_reg_ptr, #0
    if_nc   movs    ay_state, #ay_allatonce
    if_nc   jmp #complete
            ' One register at a time
            mov     ay_reg_ptr, bus_data
            movs    ay_state, #ay_oneatatime
            jmp #complete

ay_oneatatime
            add     ay_reg_ptr, ay_ptr
            wrbyte  bus_data, ay_reg_ptr
            movs    ay_state, #ay_start
            jmp #complete

ay_allatonce
            mov     TMP, ay_reg_ptr
            add     TMP, ay_ptr
            wrbyte  bus_data, TMP
            add     ay_reg_ptr, #1
            cmp     ay_reg_ptr, #16  wz
   if_z     movs    ay_state, #ay_start
            jmp #complete

ay_BEL
            mov    ay_reg_ptr, ay_ptr
            wrlong ay_BEL0, ay_reg_ptr
            add    ay_reg_ptr, #4
            wrlong ay_BEL1, ay_reg_ptr
            add    ay_reg_ptr, #4
            wrlong ay_BEL2, ay_reg_ptr
            add    ay_reg_ptr, #4
            wrlong ay_BEL3, ay_reg_ptr
ay_BEL_ret  ret

' - - - - - - - - - - - - - - - -

' - - - - Custom timer update state machine

ct_read
            mov     TMP, phsb
            shr     TMP, #31
            and     TMP, #$FF

            shl     TMP, #Z_D0
            mov     dira, z80_DIRRD  ' change dira pins to allow output to data bus
            mov     outa, TMP       ' write byte to bus
            mov     ctra, z80_CTR    ' reenable Z80 clock
            waitpne  bus_mask, bus_data ' wait for bus state to change: Z80 should bring Z_RD high (inactive) after reading from data bus
            'mov     ctra, #0        ' pause Z80 clock
            mov     dira, z80_DIRWR  ' change outa pins back to mask/prevent writing to data bus
            mov     outa, #0        ' bring the data bus back low
            jmp #complete

ct_start
            cmp     bus_data, #1       wc
    if_nc   movs    ct_state, #ct_persecond  ' OUT 130, 1
    if_c    movs    ct_state, #ct_direct_1   ' OUT 130, 0
            jmp #complete

ct_persecond
            ' calculate ct_FRQ based on {bus_data}/s ... table lookup, even from hub, might be fastest
            ' mov     frqb, ct_FRQ
            movs    ct_state, #ct_start
            jmp #complete

ct_direct_1
            mov     ct_FRQ, bus_data
            movs    ct_state, #ct_direct_2
            jmp #complete

ct_direct_2
            shl     bus_data, #8
            or      ct_FRQ, bus_data
            movs    ct_state, #ct_direct_3
            jmp #complete

ct_direct_3
            shl     bus_data, #16
            or      ct_FRQ, bus_data
            movs    ct_state, #ct_direct_4
            jmp #complete

ct_direct_4
            shl     bus_data, #24
            or      ct_FRQ, bus_data
            mov     frqb, ct_FRQ
            movs    ct_state, #ct_start
            jmp #complete

' - - - - - - - - - - - - - - - -



' - - - - Complete: reenable the Z80 clock and wait until the Z80 stops asserting A7 and !IORQ
complete
            mov     ctra, z80_CTR           ' reenable Z80 clock
            waitpne bus_pattern, bus_mask  ' wait until z80 is ready
            jmp     #loop

' - - - - Jumping off point for catching unexpected IO requests, just dump bus_data for now
unhandled
            mov debug, bus_data
            call #dumpdebug
            jmp #complete


' Outputs debug to the terminal in hex.  This is generally the state of ina (the bus) on IORQ.
' Commented-out for now because it is too terrible.  If it's ever needed it should be rewritten
' to do a similar thing, but not 8x cut-and-pasted code.
dumpdebug
{
            ' D E B U G - - - - - - - - - - - - - - - - - - - - -
            mov     TMP, debug
            shr     TMP, #28
            and     TMP, #15
            add     TMP, #48
            cmp     TMP, #58  wc
    if_nc   add     TMP, #7
            rdlong  tail, tail_ptr
            mov     TailPtr, tail
            add     TailPtr, queue_ptr
            wrbyte  TMP, TailPtr  ' only copies lowest byte
            add     tail, #1
            and     tail, cap_mask
            wrlong  tail, tail_ptr

            mov     TMP, debug
            shr     TMP, #24
            and     TMP, #15
            add     TMP, #48
            cmp     TMP, #58  wc
    if_nc   add     TMP, #7
            rdlong  tail, tail_ptr
            mov     TailPtr, tail
            add     TailPtr, queue_ptr
            wrbyte  TMP, TailPtr  ' only copies lowest byte
            add     tail, #1
            and     tail, cap_mask
            wrlong  tail, tail_ptr

            mov     TMP, debug
            shr     TMP, #20
            and     TMP, #15
            add     TMP, #48
            cmp     TMP, #58  wc
    if_nc   add     TMP, #7
            rdlong  tail, tail_ptr
            mov     TailPtr, tail
            add     TailPtr, queue_ptr
            wrbyte  TMP, TailPtr  ' only copies lowest byte
            add     tail, #1
            and     tail, cap_mask
            wrlong  tail, tail_ptr

            mov     TMP, debug
            shr     TMP, #16
            and     TMP, #15
            add     TMP, #48
            cmp     TMP, #58  wc
    if_nc   add     TMP, #7
            rdlong  tail, tail_ptr
            mov     TailPtr, tail
            add     TailPtr, queue_ptr
            wrbyte  TMP, TailPtr  ' only copies lowest byte
            add     tail, #1
            and     tail, cap_mask
            wrlong  tail, tail_ptr

            mov     TMP, debug
            shr     TMP, #12
            and     TMP, #15
            add     TMP, #48
            cmp     TMP, #58  wc
    if_nc   add     TMP, #7
            rdlong  tail, tail_ptr
            mov     TailPtr, tail
            add     TailPtr, queue_ptr
            wrbyte  TMP, TailPtr  ' only copies lowest byte
            add     tail, #1
            and     tail, cap_mask
            wrlong  tail, tail_ptr

            mov     TMP, debug
            shr     TMP, #8
            and     TMP, #15
            add     TMP, #48
            cmp     TMP, #58  wc
    if_nc   add     TMP, #7
            rdlong  tail, tail_ptr
            mov     TailPtr, tail
            add     TailPtr, queue_ptr
            wrbyte  TMP, TailPtr  ' only copies lowest byte
            add     tail, #1
            and     tail, cap_mask
            wrlong  tail, tail_ptr

            mov     TMP, debug
            shr     TMP, #4
            and     TMP, #15
            add     TMP, #48
            cmp     TMP, #58  wc
    if_nc   add     TMP, #7
            rdlong  tail, tail_ptr
            mov     TailPtr, tail
            add     TailPtr, queue_ptr
            wrbyte  TMP, TailPtr  ' only copies lowest byte
            add     tail, #1
            and     tail, cap_mask
            wrlong  tail, tail_ptr

            mov     TMP, debug
            shr     TMP, #0
            and     TMP, #15
            add     TMP, #48
            cmp     TMP, #58  wc
    if_nc   add     TMP, #7
            rdlong  tail, tail_ptr
            mov     TailPtr, tail
            add     TailPtr, queue_ptr
            wrbyte  TMP, TailPtr  ' only copies lowest byte
            add     tail, #1
            and     tail, cap_mask
            wrlong  tail, tail_ptr

            mov     TMP, #32
            rdlong  tail, tail_ptr
            mov     TailPtr, tail
            add     TailPtr, queue_ptr
            wrbyte  TMP, TailPtr  ' only copies lowest byte
            add     tail, #1
            and     tail, cap_mask
            wrlong  tail, tail_ptr
            ' D E B U G - - - - - - - - - - - - - - - - - - - - -
}
dumpdebug_ret  ret



TMP             long    0
debug           long    0

' terminal emulation queue
queue_ptr       long    0
'head_ptr       long    0  ' not needed
tail_ptr        long    0
tail            long    0
cap_mask        long    0

' Z80 read/write pins
z80_DIRRD       long    0
z80_DIRWR       long    0
bus_pattern     long    0
bus_mask        long    0
bus_data        long    0
io_addr         long    0

' Z80 clock
z80_CTR         long    0
z80_FRQ         long    0  ' NCO FRQ register value, not "clock frequency"

' custom timer
ct_state        long    0
ct_CTR          long    0
ct_FRQ          long    0


' AY3891X emulation
ay_ptr          long    0
ay_state        long    0
ay_reg_ptr      long    0
'AY BEL: $FD,$00, $BA,$00, $8E,$00,  $00,  $38,  $10,$10,$10,  $A1,$07,  $09,  $00,$00
ay_BEL0         long     $FD, $00, $BA, $00
ay_BEL1         long     $8E, $00, $00, $38
ay_BEL2         long     $10, $10, $10, $A1
ay_BEL3         long     $07, $09, $00, $00

' direct framebuffer (VGA)
dfb_state       long     0  ' direct frame buffer state machine "next state" pointer
dfb_screen_ptr  long     0
dfb_cols        long     0
dfb_rows        long     0
dfb_write_ptr   long     0
dfb_count       long     0

dfc_state       long     0
dfc_screen_ptr  long     0
dfc_write_ptr   long     0

' serial terminal mirror
tx              long     0