<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Alice&nbsp;4 FPGA Rasterizer</title>
        <link href='https://fonts.googleapis.com/css?family=Sorts+Mill+Goudy:400,400italic' rel='stylesheet' type='text/css'>
        <link href="../base.css" rel="stylesheet" type="text/css">
    </head>
    <body onload="WaveDrom.ProcessAll()">
        <div class="content">
            <h1>Alice&nbsp;4 FPGA Rasterizer</h1>

            <h2>Overview</h2>

            <p>The Alice 4 rasterizer is broken into two main parts:</p>

            <ul>
                <li>A software library linked with the C application program. The library
                    implements the IrisGL API. It performs transformations, lighting, clipping,
                    and retained mode (display lists). Its output is a list of commands
                    (clear screen, draw triangle, swap buffers, etc.) that it writes to
                    memory outside Linux's range.</li>
                <li>An FPGA configuration that reads these commands from SDRAM and
                    executes them. For triangles it interpolates color (RGB) and depth
                    (Z). The FPGA also scans out the image buffer to the
                    LCD and performs other minor tasks.</li>
            </ul>

            <h2>Buffers</h2>

            <p>There are three image buffers in shared memory:</p>

            <ul>
                <li>A front color buffer, which is displayed to the user via the LCD.
                The scanning is continuous because the LCD has no memory of its own.
                The timing and wire format is similar to VGA.</li>
                <li>A back color buffer, which is being rasterized into.</li>
                <li>A depth buffer, used along with the back buffer during rasterization.</li>
            </ul>

            <p>The first two buffers are only virtually “front” and “back”. Those two
            labels switch every frame as the back buffer becomes the new front
            buffer and is shown to the user.</p>

            <h2>Modules</h2>

            <p>The Verilog code is broken into about a dozen modules:</p>

            <ul>
                <li>Main: Integrates all the other modules.
                    <ul>
                        <li>soc_instance: Module generated by Qsys to interface with
                            SDRAM and I<sup>2</sup>C.</li>
                        <li>LCD_control: Generates LCD control signals (H-Sync, V-Sync,
                            pixel enable, next frame signal, X coordinate, Y coordinate).
                            This runs at 25&nbsp;MHz (about 50&nbsp;FPS). It could run faster (up to 40&nbsp;MHz)
                            but the board clock is 50&nbsp;MHz, so it was convenient to
                            divide that by two and avoid having asynchronous clocks.</li>
                        <li>LCD_text: Given screen pixel X and Y, returns character X and Y
                            (text column and row) and sub-character X and Y.</li>
                        <li>LCD_debug: Given character X and Y and three 32-bit debug values,
                            returns which character to draw.
                            <ul>
                                <li>Binary_to_hex: Converts a nybble to a hex
                                    ASCII value. Used for each nybble of the
                                    debug values to generate hex output.</li>
                            </ul>
                        </li>
                        <li>Frame_buffer: Sends the front frame buffer to the LCD.</li>
                        <li>LCD_font: Given ASCII character and sub-character X and Y,
                            returns whether the pixel is on or off.
                            <ul>
                                <li>Font_ROM: The font pixels.</li>
                            </ul>
                        </li>
                        <li>Command_reader: Pre-fetches drawing commands from
                            SDRAM into a FIFO.</li>
                        <li>Rasterizer: Reads drawing commands and executes them.
                            <ul>
                                <li>Read_FIFO: Queues rasterized pixels,
                                    waiting for Z read to complete.</li>
                                <li>Write_FIFO: Queues rasterized and Z-compared
                                    pixels, waiting for pixel writes to complete.
                                    See the “Write FIFO” section below for more details.</li>
                            </ul>
                        </li>
                        <li>Prescaler: Generates a tick every N clocks.</li>
                        <li>PWM: Generates a PWM signal for LCD backlight brightness.</li>
                        <li>Debouncer: Debounces the Home button.</li>
                    </ul>
                </li>
            </ul>

            <h2>Memory controller</h2>

            <p>The Altera Cyclone V SoC has a wonderful memory controller for accessing
            the synchronous dynamic RAM (SDRAM). It has a port for the ARM and six ports
            for the FPGA. Each FPGA port can be configured for input or output, and their
            relative priorities (including the ARM port) can be set. The priorities were
            critical for making sure the front-buffer scan-out was never starved of
            pixels. The SDRAM itself ran so fast (400&nbsp;MHz DDR) that all the ports could
            be active and not stall too often. The ports were set up as follows:</p>

            <ul>
                <li>Reading the front-buffer for LCD scan-out. This was configured
                to be the highest priority.</li>
                <li>Reading the graphics command buffer.</li>
                <li>Reading the depth buffer for the pixel being rasterized.</li>
                <li>Writing the color of the pixel just rasterized.</li>
                <li>Writing the depth of the pixel just rasterized.</li>
            </ul>

            <p>All five ports were hooked up to FIFOs to minimize the effects of
            memory latency.</p>

            <h2>Rasterization</h2>

            <p>Rasterization uses the edge-equation technique. The idea is to test every
            pixel to see whether it's inside the triangle. “Inside” is defined as “on the
            same side of every edge”. Only pixels in the bounding box of the triangle are
            tested. This technique wastes at least 50% of its time on pixels outside the
            triangle, but it's simpler to implement than edge-walkers.</p>

            <p>The state machine in <tt>Rasterizer.v</tt> reads commands from SDRAM
            (indirectly through the FIFO) and executes them. Because the SDRAM interface
            is (logically) 64 bits wide, and each pixel takes 32 bits (8 bits each of
            red, green, and blue, with 8 bits wasted), we always rasterize two pixels
            at a time. At 50&nbsp;MHz, that's 100 million pixels per second, but with (at least)
            half of them wasted, that's at most 50 million drawn pixels per second.</p>

            <p>To minimize SDRAM latency stalls, we use three FIFOs in the rasterization
            process:</p>
            
            <ul>
                <li>The Command FIFO queues the drawing commands so that the
                    state machine need not block too long.</li>
                <li>The Read FIFO queues drawn pixels while we wait for the
                    depth read to return. After determining that a pixel is
                    inside the triangle, we initiate a read of its
                    corresponding depth value (if depth-comparison is enabled
                    for this triangle). This can take some time (tens of clocks) and we don't
                    want to block the rasterizer. Instead, we queue up all the
                    information we have about this pixel (depth memory address,
                    depth value, color memory address, and color) and move on to the
                    next pixel.
                    Another module (<tt>Read_FIFO.v</tt>) waits for the SDRAM read
                    to return. Since SDRAM reads return in the order they were
                    made, the module then gets the next item in our FIFO,
                    compares the depth values, and if the new pixel is closer to
                    the camera than the existing pixel, enqueues the same pixel
                    information into the Write FIFO. (All of this is done two
                    pixels at a time.)</li>
                <li>The Write FIFO queues pixels that must be written back to SDRAM.
                    The pixel's color must be written, and optionally the depth value
                    must be written (if enabled for this triangle). This is a complicated
                    module because we must take into account whether there are pixels
                    in the FIFO to write, whether the depth memory controller is ready
                    to accept another write, and whether the color memory controller is
                    ready to accept another write. See the section “Write FIFO” below
                    for details.</li>
            </ul>

            <p>There's very little stalling in this pipeline, so we end up with a
            rasterization rate of about 50 million Gouraud (color-interpolated)
            Z-buffered pixels per second. The triangle overhead lets us do
            almost 2 million (empty) triangles per second. It's hard to compare
            these numbers to
            <a href="http://www.sgidepot.co.uk/gfxtables.html">real SGI machines</a>, 
            but we seem to be matching the performance of machines built in the
            early 1990s.</p>

            <h2>Reciprocal</h2>

            <p>For each triangle, the rasterizer computes the on-screen area, then takes
            the reciprocal of the area. To compute the reciprocal we use the built-in
            <a href="https://www.altera.com/en_US/pdfs/literature/ug/ug_lpm_alt_mfug.pdf"><tt>lpm_divide</tt></a> module:</p>

            <pre>
lpm_divide
    #(.LPM_WIDTHN(32),
      .LPM_WIDTHD(32),
      .LPM_NREPRESENTATION("UNSIGNED"),
      .LPM_DREPRESENTATION("SIGNED"),
      .LPM_PIPELINE(6)) area_divider(
        .clock(clock),
        .clken(area_reciprocal_enabled),
        .numer(32'h7FFF_FFFF),
        .denom(tri_area),
        .quotient(tri_area_recip_result)
    );
            </pre>

            <p>The module is configured to have six pipeline stages, which means that
            the result will come out six clocks after the denominator was put in.
            We don't pipeline (overlap) our reciprocals (we only need one per triangle), but our
            state machine must wait six clocks for this result. We found the
            number 6 by trying various values until the compiler stopped complaining
            about timing violations.</p>

            <h2>Write FIFO</h2>

            <p>The Write FIFO, which writes pixel data to the back color buffer and
            to the depth buffer, was one of the most difficult modules to write in
            this project. Conceptually the state machine should perform these
            steps in a loop:</p>

            <ol>
                <li>Wait for a new pixel to be available in the Write FIFO.</li>
                <li>Write it to the back color buffer and to the depth buffer.</li>
                <li>Wait for both SDRAM controller ports to acknowledge that they had
                    accepted the writes.</li>
            </ol>

            <p>Remember that wherever we talk about “a pixel” here, we mean two
            side-by-side pixel pairs that are handled in parallel. The FIFOs include
            two bits to specify which of the two pixels (or both) are valid, since
            either (but not both) could be outside the triangle.</p>

            <p>This sequential version is much too slow. It would introduce
            several wait states, destroying our throughput. It is implemented
            in the <tt>!PIPELINED</tt> sections of the <tt>Write_FIFO.v</tt> module,
            but this code is disabled in favor of the <tt>PIPELINED</tt> code described
            below.</p>

            <p>There are several difficulties involved in doing the above steps
            concurrently:</p>

            <ul>
                <li>We can initiate a read of the FIFO, but it's not until the next
                    cycle that we know whether the FIFO had anything to give us, and
                    the cycle after that that we get the data.</li>
                <li>We can write to a memory port, but it's not until the next cycle
                    that we're told whether the port can accept our write. If not, we
                    must hold our write until the port accepts it.</li>
                <li>It is therefore not until <i>three clocks</i> after initiating a FIFO
                    read that we know whether we're stalled by the SDRAM! In that
                    time we must keep reading from the FIFO (to maintain our
                    bandwidth). Any FIFO reads we had initiated in the meantime will
                    complete and the results must be stored somewhere: a tiny two-entry
                    FIFO made of two registers (called “slots”).</li>
                <li>We're writing to two memory ports (color and depth) and either or
                    both could stall.</li>
            </ul>

            <p>To solve all these problems we put the current state of the system into
            a five-bit value and switch on this value to determine what to do. The value
            has the following bits:</p>

            <ul>
                <li>Bit 4: Whether we currently have data back from the FIFO read. This
                is the logical “AND” of whether we asked for a read two clocks ago
                and were told one clock ago that the FIFO wasn't empty.</li>
                <li>Bit 3: Whether the color memory port is asking us to wait. This
                is the logical “AND” of whether we asked for a write last clock
                and are told this clock to wait.</li>
                <li>Bit 2: Whether the depth memory port is asking us to wait.</li>
                <li>Bit 1: Whether the first slot is full. We have a bit to keep track of this.</li>
                <li>Bit 0: Whether the second slot is full.</li>
            </ul>

            <p>There are 32 combinations of these five bits, but they map to
            only 11 different behaviors, of which two are error cases (e.g.,
            data in slot 2 but no data in slot 1). A few examples:</p>
            
            <ul>
                <li>For the value <tt>10000</tt>, we have new data from the FIFO, the
                    memory ports aren't blocked, and there's nothing in the slots. We
                    can write the FIFO's data to memory immediately. This is the most
                    common case.</li>
                <li>For values <tt>11100</tt>, <tt>10100</tt>, and <tt>11000</tt>, we
                    have new data from the FIFO but one or both of the memory ports
                    are blocked, and none of the slots are used. Put the FIFO data into
                    slot 1.</li>
                <li>For value <tt>00011</tt>, we have no new FIFO data and the memory
                    is not blocked, but both slots are full. Write slot 1 to memory
                    and move slot 2 to slot 1.</p>
            </ul>

            <p>See the <tt>casez</tt> statement in the <tt>Write_FIFO.v</tt> file for
            all cases.</p>

            <p>The amazing <a href="http://wavedrom.com/">WaveDrom</a> package will be
            used to illustrate the common cases. Only the color memory port is shown,
            but the same logic would apply to depth. First, a single fetch from the
            FIFO, written to memory:</p>

            <script type="WaveDrom">
                {head: {
                  text: 'Single write',
                  tick: 0
                }, signal: [
                  {name: 'clock',         wave: 'P.....'},
                  {name: 'read FIFO',     wave: '010...'},
                  {name: 'FIFO empty',    wave: 'x0x...'},
                  {name: 'FIFO data',     wave: 'x.3x..', data: "A"},
                  {name: 'slot 2',        wave: 'x.....'},
                  {name: 'slot 1',        wave: 'x.....'},
                  {name: 'color data',    wave: 'x..3x.', data: "A"},
                  {name: 'color write',   wave: '0..10.'},
                  {name: 'color wait',    wave: '0.....', phase: 0.5},
                ]}
            </script>

            <p>At clock 1 we initiate the FIFO read, at clock 2 we find that it
            succeeded (the FIFO is not empty), and at clock 3 we can read the data
            and simultaneously write it to the SDRAM. In the next example we
            write two (pairs of) pixels sequentially, and neither blocks:</p>

            <script type="WaveDrom">
                {head: {
                  text: 'Double write',
                  tick: 0
                }, signal: [
                  {name: 'clock',         wave: 'P......'},
                  {name: 'read FIFO',     wave: '01.0...'},
                  {name: 'FIFO empty',    wave: 'x0.x...'},
                  {name: 'FIFO data',     wave: 'x.45x..', data: "B C"},
                  {name: 'slot 2',        wave: 'x......', data: ""},
                  {name: 'slot 1',        wave: 'x......', data: ""},
                  {name: 'color data',    wave: 'x..45x.', data: "B C"},
                  {name: 'color write',   wave: '0..1.0.'},
                  {name: 'color wait',    wave: '0......', phase: 0.5},
                ]}
            </script>

            <p>For the next example, one cycle after our memory write the controller
            tells us to wait. We must hold the data and the write signal indefinitely
            (though in this case only one extra cycle):</p>

            <script type="WaveDrom">
                {head: {
                  text: 'Memory stall',
                  tick: 0
                }, signal: [
                  {name: 'clock',         wave: 'P......'},
                  {name: 'read FIFO',     wave: '010....'},
                  {name: 'FIFO empty',    wave: 'x0x....'},
                  {name: 'FIFO data',     wave: 'x.3x...', data: "D"},
                  {name: 'slot 2',        wave: 'x......', data: ""},
                  {name: 'slot 1',        wave: 'x......', data: ""},
                  {name: 'color data',    wave: 'x..3.x.', data: "D"},
                  {name: 'color write',   wave: '0..1.0.'},
                  {name: 'color wait',    wave: '0...10.', phase: 0.5},
                ]}
            </script>

            <p>We can now combine our previous two examples. We read three
            pixels from the FIFO, but the first is stalled one cycle when
            writing to memory. We must write the second pixel to slot 1, then
            the next cycle simultaneously write slot 1 to memory and replace
            it with the third pixel:</p>

            <script type="WaveDrom">
                {head: {
                  text: 'Use of slot 1',
                  tick: 0
                }, signal: [
                  {name: 'clock',         wave: 'P........'},
                  {name: 'read FIFO',     wave: '01..0....'},
                  {name: 'FIFO empty',    wave: 'x0..x....'},
                  {name: 'FIFO data',     wave: 'x.345x...', data: "E F G"},
                  {name: 'slot 2',        wave: 'x........', data: ""},
                  {name: 'slot 1',        wave: 'x...45x..', data: "F G"},
                  {name: 'color data',    wave: 'x..3.45x.', data: "E F G"},
                  {name: 'color write',   wave: '0..1...0.'},
                  {name: 'color wait',    wave: '0...10...', phase: 0.5},
                ]}
            </script>

            <p>This last example uses both slots because the first pixel
            stalls for two cycles. This is the worst-case scenario because
            at cycle 4 we realize that the first pixel's write has stalled
            and we stop fetching from the FIFO. Even if the stall lasts longer
            than two cycles, we don't have any more than two pixels to write to
            the slots:</p>

            <script type="WaveDrom">
                {head: {
                  text: 'Use of both slots',
                  tick: 0
                }, signal: [
                  {name: 'clock',         wave: 'P.........'},
                  {name: 'read FIFO',     wave: '01..0.....'},
                  {name: 'FIFO empty',    wave: 'x0..x.....'},
                  {name: 'FIFO data',     wave: 'x.345x....', data: "H I J"},
                  {name: 'slot 2',        wave: 'x....5x...', data: "J"},
                  {name: 'slot 1',        wave: 'x...4.5x..', data: "I J"},
                  {name: 'color data',    wave: 'x..3..45x.', data: "H I J"},
                  {name: 'color write',   wave: '0..1....x.'},
                  {name: 'color wait',    wave: '0...1.0...', phase: 0.5},
                ]}
            </script>

            <p><a href="./">&laquo; Back</a></p>
        </div>

        <script src="wavedrom-1.4.1/skins/default.js" type="text/javascript"></script>
        <script src="wavedrom-1.4.1/wavedrom.min.js" type="text/javascript"></script>
    </body>
</html>
